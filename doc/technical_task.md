# Техническое задание: Telegram-бот @fast_telegram_srm

## 1. Цель проекта
Создать отказоустойчивого Telegram-бота для автоматического сбора и систематизации данных о новых подписчиках, присоединившихся по пригласительным ссылкам, с выгрузкой в Google Sheets для онлайн-мониторинга.

---

## 2. Архитектура и технологический стек

* **Язык программирования:** `Python 3.11+`.
* **Основной фреймворк:** `Aiogram 3.x`. Выбран за асинхронную архитектуру, позволяющую эффективно обрабатывать большое количество одновременных событий от разных каналов без блокировок.
* **Взаимодействие с Google Sheets:**
    * **Библиотека:** `gspread` для основной логики и `gspread-asyncio` для асинхронной интеграции с Aiogram. Это предотвратит блокировку event loop при выполнении сетевых запросов к Google API.
    * **Аутентификация:** Через **сервисный аккаунт Google Cloud**. Для работы потребуется JSON-ключ, а email сервисного аккаунта должен быть добавлен в редакторы целевого Google-документа.
* **Локальная база данных:** `SQLite` с асинхронным драйвером `aiosqlite`.
    * **Назначение:** Будет использоваться для внутреннего кеширования. В ней будет храниться карта соответствия `channel_id` ↔ `google_sheet_name`, чтобы избежать лишних API-запросов к Google при каждом новом подписчике.
* **Конфигурация:** Секретные данные (токен бота, ключи API) будут храниться в **переменных окружения** и загружаться в приложение при старте (например, через `.env` файл и библиотеку `python-dotenv`).
* **Развертывание:**
    * **Окружение:** Linux-сервер (рекомендовано Ubuntu 22.04 LTS).
    * **Процесс:** Бот будет запущен как **`systemd-сервис`**, что обеспечит его автоматический перезапуск при сбоях или после перезагрузки сервера.

---

## 3. Логика работы и функции

### 3.1. Инициализация канала
1.  При добавлении бота в новый канал с правами администратора, бот перехватывает событие `my_chat_member`.
2.  Он извлекает `ID` и `название` канала.
3.  Проверяет в локальной SQLite базе, есть ли запись для этого `ID`.
4.  Если нет, бот обращается к Google Sheets, создает новый лист с названием канала (если такого еще не существует) и добавляет в него заголовочную строку с названиями полей.
5.  После успешного создания листа, бот сохраняет пару `channel_id` и `sheet_name` в свою SQLite базу.

### 3.2. Отслеживание нового подписчика
1.  Создается обработчик (`handler`) для события `chat_member`, который срабатывает только при выполнении двух условий (с использованием фильтров Aiogram):
    * Статус нового участника — `member`.
    * Событие содержит объект `invite_link` (т.е. пользователь пришел по ссылке).
2.  При срабатывании обработчика, бот извлекает из события все необходимые данные.

### 3.3. Запись данных
1.  Получив данные о новом подписчике, бот по `channel_id` быстро находит из локальной SQLite базы имя нужного листа в Google-таблице.
2.  Формируется строка для добавления в таблицу.
3.  С помощью `gspread-asyncio` выполняется асинхронный вызов `append_row` для добавления данных в конец соответствующего листа.

---

## 4. Структура данных для записи
В Google Sheets для каждого канала будет создана таблица со следующими столбцами:

| Название столбца | Источник данных (объект API) | Пример |
| :--- | :--- | :--- |
| **Timestamp** | `datetime.now()` | `2025-09-15 14:32:10` |
| **User ID** | `user.id` | `123456789` |
| **Full Name** | `user.full_name` | `Иван Петров` |
| **Username** | `user.username` | `@ivan_petrov` |
| **Invite Link** | `invite_link.invite_link` | `https://t.me/+a1b2c3d4e5f6` |
| **Link Name** | `invite_link.name` | `Реклама ВК Сентябрь`|

---

## 5. Итоговые результаты (Deliverables)
1.  **Исходный код** проекта на Python, структурированный и прокомментированный.
2.  **Инструкция** по развертыванию (`README.md`), включающая установку зависимостей и настройку конфигурационных файлов.
3.  **Развернутый и запущенный** на сервере заказчика бот, работающий в режиме 24/7.
4.  Ссылка на **мастер-файл Google Sheets**, настроенный для работы с ботом.